# Вибір фреймворку
## Для побудови невеликого сервісу збору подій з API потрібен швидкий та легкий фреймворк.
## Варіанти 
- Варіант A: **FastAPI.** (Плюси: найкраща швидкість обробки запитів за рахунок підтримки повноцінної підтримки асинхронності. Мінуси: в нашому контексті суттєвих мінусів FastAPI немає.)
- Варіант B: **Flask.** (Плюси: простота. Мінуси: погана швидкість обробки запитів в силу обмеженої підтримки асинхронності.)
- Варіант C: **Django.** (Плюси: велика кількість бібліотек. Мінуси: громіздкий, погано підходить для невеликих сервісів.)
## Рішення
FastAPI. У більшості випадків для побудови сучасних REST або event-driven API оптимальним вибором є FastAPI завдяки повноцінній підтримці асинхронності.

# Вибір типу основної БД
## Сервіс має зберігати та діставати події з бази даних.
## Варіанти 
- Варіант A: **Реляційна.** (Плюси: Чітка структура даних. Мінуси: Менш гнучка при зміні структури даних.)
- Варіант B: **NoSQL** (Плюси: Висока гнучкість структури даних. Мінуси: Менш ефективна робота зі структурованими даними.)
## Рішення
Реляційна. Адже події завжди мають чітку структуру.

# Вибір реляційної БД
## Варіанти 
- Варіант A: **PostgreSQL**: (Плюси: Гарна інтеграція з Python (SQLAlchemy, psycopg), висока продуктивність і стабільність. Мінуси: Налаштування може бути складнішим, ніж у SQLite або MySQL.) 
- Варіант B: **MySQL**: (Плюси: Простота налаштування та адміністрування. Мінуси: Менш гнучка робота з JSON і нетиповими типами даних ніж у Postgres.)
- Варіант C: **SQLite**: (Плюси: простота використання, йде "з коробки". Мінуси: Не підходить для багатопоточних або високонавантажених середовищ.) 
## Рішення
PostgreSQL. Має найкращу сумісність з FastAPI стеком: SQLAlchemy, Alembic, asyncpg або psycopg3.

# Вибір in-memory БД
## Існує потреба обробки великої кількості запитів без блокування роботи API.
Для швидкої обробки недостатьно мати тільки основну базу, тому інсує потреба інтегрувати in-memory БД. 
## Варіанти 
- Варіант A: **Redis**: (Плюси: Дуже висока швидкість читання й запису. Мінуси: в нашому контексті мінусів не бачу.) 
- Варіант B: **Memcached**: (Плюси: Простий, надзвичайно швидкий кеш. Мінуси: Підтримує лише ключ-значення.) 
- Варіант C: **Hazelcast**: (Плюси: Підтримує розподілене in-memory зберігання. Мінуси: Складніша конфігурація, ніж Redis або Memcached.) 
## Рішення
Redis з воркером. Оскільки він поєднує простоту, швидкодію та гнучкість:  
підходить і для кешування, і для тимчасового зберігання, і для стрімінгу подій у реальному часі.

# Вибір аналітичної БД
## Варіанти 
- Варіант A: **DuckDB** (Плюси: Добре інтегрується з Python, дуже швидка для невеликих обсягів даних. Мінуси: В нашому контексті мінусів не бачу.) 
- Варіант B: **ClickHouse** (Плюси: Оптимізований для великих обсягів подій. Мінуси: Важча ніж в DuckDB установка і конфігурація.)
- Варіант C: **Apache Druid** (Плюси: Оптимізована для потокових подій і аналітики в реальному часі. Мінуси: Overkill для невеликих сервісів.)
## Рішення 
DuckDB. Через гарну швидкість та простоту в налаштуванні.

# Вибір драйверу для асинхронності.
## Варіанти 
- Варіант A: **Psycopg** (Плюси: Добре інтегрується з Python, дуже швидка для невеликих обсягів даних. Мінуси: В нашому контексті мінусів не бачу.) 
- Варіант B: **Asyncpg** (Плюси: Оптимізований для великих обсягів подій. Мінуси: Важче ніж в Psycopg встановлення і конфігурація.)
## Рішення 
Psycopg. Моїм першим вибором був Asyncpg, але на момент початку роботи над проєктом він не був оптимізований для роботи з Python 3.14.
